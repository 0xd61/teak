// This file demonstrates the usage and syntax of the main language features.
// Line comments begin with two forward slashes.

void Start() {
	// The script starts executing in the Start function.

	// Variables are declared by putting the type name then the variable name.
	// All variables are initialized to 0 or an empty value, depending on the type.
	int x;
	// You can set the value of a variable with equals.
	x = 5;
	// You can also set the value of a variable when it is declared.
	int y = 3;

	// Standard integer arithmetic and bitwise operators are available.
	int z = ((3 * x + y / (1 + 1)) << 1) | 1;
	// The only unconventional syntax is for bitwise XOR.
	z = z ~| 10;
	// Some arithmetic operators can be merged with assignment.
	x += 10;

	// Strings are delimited by speech marks.
	Log("Hello!");
	// You can escape special characters using a backslash.
	Log("\\ \" \%");
	// You can insert special characters using a backslash.
	Log("\n \r \t");
	// You can insert an expression into a string delimiting it with percentage signs.
	Log("The value of y is %y%.");

	// The basic types are bool (true or false), float (double precision), 
	// int (64-bit, signed) and str (immutable byte array).
	bool b0 = true;
	float f0 = 10.5;
	int i0 = -100;
	str s0 = "String";
	
	// You can index specific byte from a string.
	str s1 = s0[5];
	Log("%s1%"); // Prints g.
	// You can concatenate strings with the add operator.
	str s2 = s1 + s0;
	Log("%s2%"); // Prints gString.
	// String equality comparison compares the individual bytes of the strings.
	// No Unicode normalization or validating is done to either string.
	assert "Hello" == "Hel" + "lo";

	// Standard logic operators (with short circuiting) are available.
	bool b1 = !b0 && (z > y || z > x);

	// Standard floating point operators are available. 
	f0 *= 2.5;
	// Floats and integers cannot be mixed.
	// f0 += i0; (won't compile)
	// Float can be cast to integers and vice-versa.
	int i1 = f0:truncate();
	float f1 = i1:float();
	Log("f0 is %f0%");
	Log("f1 is %f1%");

	// There are while loops.
	int count = 0;
	while i0 < 0 {
		count += 1;
		i0 += 1;
	}
	Log("count is %count%.");

	// There are for loops.
	for int i = 0; i < 5; i += 1 {
		Log("%i + 1%/5");
	}

	// There are for-in loops.
	// These work with strings and lists. We'll look at lists later.
	// For strings, they enumerate over each byte (not codepoints or characters!).
	for str byte in "Hello" {
		Log("%byte%");
	}

	// There are if, else if and else statements.
	if count > 100 {
		Log("count is large");
	} else if count > 50 {
		Log("count is medium");
	} else {
		Log("count is small");
	}

	// You can assert a boolean expression is true.
	// If it is false, the script stops and prints a back trace.
	assert count == 100;

	// Functions are called by putting the name of the function,
	// and then the arguments in round brackets.
	int result = MyFunction(1, 2, 3);
	Log("result of MyFunction is %result%.");
	Part2();
}

// To declare a function, first put the return type (or void, if it does not return a value).
// Then the name of the function, followed by a round bracketed list of arguments.
int MyFunction(int a, int b, int c) {
	// You can return a value from a function using a return statement.
	return a + b + c;
}

void Part2() {
	// List types are made by putting [] after the element type.
	int[] list;

	// Lists start as null objects.
	assert list == null;
	Log("%list%");
	// You can get the length of a list using the :len() op.
	assert list:len() == 0;

	// You can create an empty list using the new operator.
	list = new int[];
	assert list != null;
	assert list:len() == 0;
	Log("%list%");

	// You can create a non-empty list by enumerating the elements between square brackets.
	list = [1, 2, 3, 5, 10];
	Log("%list%");
	Log("%list:len()%");
	// You can't use the bracket syntax to create an empty list.
	// list = []; (won't compile)
	// All the elements of a list must have the same type.
	// list = [3, "String"]; (won't compile)

	// You can get the first and last elements of a list.
	assert list:first() == 1;
	assert list:last() == 10;
	// You can index a specific element of a list. Indices start at 0.
	assert list[2] == 3;
	list[0] = -5;

	// You can find the index of an element in the list.
	assert list:find(3) == 2;
	// If the element isn't found, -1 is returned.
	assert list:find(100) == -1;

	// You can resize the list to a specific size.
	// New space is initialized to the variable type's default value (e.g. 0).
	list:resize(4);
	list:resize(6);
	Log("%list%"); // Prints [ -5, 2, 3, 5, 0, 0 ].

	// You can add elements at the end of the list.
	list:add(20);
	assert list:last() == 20;
	// Or at a specific index.
	list:insert(30, 1);
	assert list[1] == 30;

	// You can insert multiple elements initialized to the default value.
	Log("%list%"); // Prints [ -5, 30, 2, 3, 5, 0, 0, 20 ].
	list:insert_many(1, 3);
	Log("%list%"); // Prints [ -5, 0, 0, 0, 30, 2, 3, 5, 0, 0, 20 ].

	// You can iterate over a list with the aforementioned for-in loop.
	for int x in list { Log("%x%"); }

	// You can delete the item at a specific index.
	list:delete(5);
	// Or find an item to delete by its value.
	// Only the first instance of the item is deleted.
	// This returns false if the value was not found.
	list:find_and_delete(30);
	Log("%list%"); // Prints [ -5, 0, 0, 0, 3, 5, 0, 0, 20 ].
	// You can delete a range of items, by the first index and the number to delete.
	list:delete_many(1, 5);
	Log("%list%"); // Prints [ -5, 0, 0, 20 ].
	// You can clear a list to an empty one.
	list:delete_all();
	Log("%list%"); // Prints [].

	// List equality ignores the contents of the list;
	// it checks if the list objects are actually the same.
	int[] l0 = [ 1, 2, 3 ];
	int[] l1 = [ 1, 2, 3 ];
	int[] l2 = l0;
	assert l0 != l1;
	assert l0 == l2;

	// Continuing in the next function...
	Part3();
}

// Structures are declared with the struct keyword,
// followed by the name of the structure,
// then a list of the fields delimited by curly brackets.
struct Vector2 {
	float x;
	float y;
};

void Part3() {
	// Structures start initialized to null.
	Vector2 v;
	assert v == null;

	// You can alllocate a new structure with the new operator.
	// All its fields will be initialized to the default value for their type.
	v = new Vector2;

	// Lists, structures and other objects are garbage collected.
	// You don't need to explicitely free them.
	v = new Vector2; // No memory is leaked here.

	// You can access a field of the structure using the dot operator.
	v.x = 3.0;
	v.y = v.x + 5.0;
	Log("(%v.x%, %v.y%)");

	// Functions can return multiple values via tuples.
	// See the function definition below.
	int x, str y = MultipleReturnValues(false);
	Log("%x% %y%");
	// You can assign variables directly, or declare new ones as above.
	x, y = MultipleReturnValues(true);
	Log("%x% %y%");

	// Continuing in the next part...
	Part4();
}

// To denote that a function returns multiple values, use the tuple syntax.
// Note that tuples can only be used for returning multiple values from a function;
// they're not allowed anywhere else in the language.
tuple[int, str] MultipleReturnValues(bool which) {
	if which {
		return 5, "World";
	} else {
		return 3, "Hello";
	}
}

// You can declare custom integer types using the keyword inttype.
inttype Flags {
	FLAG1 = 1 << 0;
	FLAG2 = 1 << 1;
	FLAG3 = 1 << 2;
};

// inttypes can inherit from other inttypes.
inttype FlagsExtended : Flags {
	FLAG4 = 1 << 3;
};

void Part4() {
	// You can perform arithmetic operations on inttypes.
	Flags f = FLAG1 | FLAG3;
	Log("%f%"); // Prints 5.

	// inttypes cannot be mixed with normal integers, except for 0.
	// f = f | 10; (won't compile)
	f = 0; // Does compile.
	// You also can't mix inttypes with other inttypes.

	// inttypes can be implicitely converted to types that inherit from them.
	FlagsExtended extended = f | FLAG4;
	// But not the other way around.
	// f = extended; (won't compile)
}

// TODO:
//	Error types
//	Function types
//	Handle types
// 	Coroutines
//	Any type
// 	Initialise function
// 	Extension libraries
// 	#option
// 	#persist
// 	Importing other modules, #inline
